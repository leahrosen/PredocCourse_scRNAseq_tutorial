---
title: "scRNA-seq Tutorial"
author: "Leah Rosen"
date: "01/11/2020"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

This tutorial roughly follows the Seurat pbms3k_tutorial: https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html with some of my own additions. For more Seurat tutorials see: https://satijalab.org/seurat/vignettes.html

We will be using some [tidyverse](www.tidyverse.org) and data.table packages. A nice blogpost outlining these is: https://wetlandscapes.com/blog/a-comparison-of-r-dialects/

# Installs

This chunk of code will install the packages. You will only need to run it once.

```{r, installs, results='hide'}
#install.packages("Seurat")
#install.packages("devtools")
#devtools::install_github('satijalab/seurat-data')
#InstallData("pbmc3k")
#install.packages("gridExtra")
#install.packages("data.table")
#install.packages("ggplot2")
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("SingleCellExperiment")
#BiocManager::install("scds")
#install.packages("useful")
```

# Imports

First, we want to import the packages we will be using.

```{r, imports, results='hide', message=FALSE}
library(Seurat)
library(SeuratData)
library(gridExtra)
library(data.table)
library(ggplot2)
library(SingleCellExperiment)
library(scds)
library(useful)
```

# Load data

The dataset we are using today is one of Seurat's example datasets. It is 2700 human peripheral blood mononucleiated cells, sequenced using 10X genomics v1.

**Note: getting the error: "no slot of name "images" for this object of class "Seurat"" is totally normal. Don't worry if you get that.**
```{r, Data}
data("pbmc3k")
pbmc3k
```

As you can see, we have now loaded a dataset with 2700 samples (i.e. cells) across 13714 features (i.e. genes). We have one "active assay", meaning we have RNA data. We can access this assay and look at the count matrix (the "head" function means that we are only displaying the first 6 rows):

```{r, ShowData}
corner(as.matrix(pbmc3k@assays$RNA@counts))
```

We also have a metadata file that gives us some information about each cell (again, we're displaying the first 6 cells)

```{r, ShowMetaData}
head(pbmc3k@meta.data)
```

# Quality Control the data

The 5 things we check when QCing a cell are:
* the number of transcripts captured (automatically saved as nCount_RNA in the metadata table)
* the number of unique genes captured  (automatically saved as nFeature_RNA in the metadata table)
* the percentage of the counts that come from mitochondrial genes (we will need to calculate this)
* the percentage of the counts that come from ribosomal transcritps (we will need to calculate this), I think these are captured due to cryptic polyadenylation (but don't quote me on this)
* whether a cell is a doublet

First, calculating the percecnt mito and percent ribo:
```{r, percent_mt_ribo}
# calculate percent counts from mitochondrial genes
pbmc3k[["percent.mt"]] <- PercentageFeatureSet(pbmc3k, pattern = "MT-")


# calculate percent counts from mitochondrial genes:
ribo.genes <- c(grep(pattern = "^RPL", x = rownames(pbmc3k), value = TRUE),grep(pattern = "^RPS", x = rownames(pbmc3k), value = TRUE))
pbmc3k[["percent.ribo"]] <- PercentageFeatureSet(pbmc3k, features = ribo.genes)
```

Note that the pattern can depend on your core or your organism. E.g. if you are given the genes as Ensembl IDs, you will first have to convert them to symbols. Or, if you're working in mouse, the genes aren't all caps, so you'll have to use "MT-" and "^Rpl", "^Rps".

Let's plot the QC metrics:
```{r, plot_QC_pre, fig.height=4, fig.width=16}
min_nFeature_RNA <- 500
min_nCount_RNA <- 1250
min_percent.mt <- 0.5
max_percent.mt <- 5

pbmc3k@meta.data$barcode <- rownames(pbmc3k@meta.data)
md <- pbmc3k@meta.data

p1 <- (ggplot(md, aes(x=nFeature_RNA)) +
  geom_density(fill="#e9ecef", position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_nFeature_RNA) +
  ggtitle(paste0("min=", min_nFeature_RNA)) +
  theme_classic())

p2 <- (ggplot(md, aes(x=nCount_RNA)) +
  geom_density(fill="#e9ecef", position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_nCount_RNA) +
  ggtitle(paste0("min=", min_nCount_RNA)) +
  scale_x_continuous(trans='log2') +
  theme_classic())

p3 <- (ggplot(md, aes(x=percent.mt)) +
  geom_density(fill="#e9ecef", position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_percent.mt) +
  geom_vline(xintercept=max_percent.mt) +
  ggtitle(paste0("min=", min_percent.mt, ", max=", max_percent.mt)) +
  scale_x_continuous(trans='log2') +
  theme_classic())

p4 <- (ggplot(md, aes(x=percent.ribo)) +
  geom_density(fill="#e9ecef", position = 'identity') +
  labs(fill="") +
  theme_classic())

grid.arrange(p1, p2, p3, p4, ncol=4)
```

```{r, FirstQC, warning=FALSE}
md$barcode <- row.names(md)
md <- as.data.table(pbmc3k@meta.data)
md$pass_QC <- TRUE
md[nFeature_RNA < min_nFeature_RNA, pass_QC := FALSE]
md[nCount_RNA < min_nCount_RNA, pass_QC := FALSE]
md[percent.mt < min_percent.mt, pass_QC := FALSE]
md[percent.mt > max_percent.mt, pass_QC := FALSE]
```

Let's plot the QC metrics splitting cells depending on whether they pass QC:
```{r, plot_QC_post, fig.height=4, fig.width=24}
p1 <- (ggplot(md, aes(x=nFeature_RNA, fill=pass_QC)) +
  geom_density(alpha=0.4, position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_nFeature_RNA) +
  ggtitle(paste0("min=", min_nFeature_RNA)) +
  theme_classic())

p2 <- (ggplot(md, aes(x=nCount_RNA, fill=pass_QC)) +
  geom_density(alpha=0.4, position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_nCount_RNA) +
  ggtitle(paste0("min=", min_nCount_RNA)) +
  scale_x_continuous(trans='log2') +
  theme_classic())

p3 <- (ggplot(md, aes(x=percent.mt, fill=pass_QC)) +
  geom_density(alpha=0.4, position = 'identity') +
  labs(fill="") +
  geom_vline(xintercept=min_percent.mt) +
  geom_vline(xintercept=max_percent.mt) +
  ggtitle(paste0("min=", min_percent.mt, ", max=", max_percent.mt)) +
  scale_x_continuous(trans='log2') +
  theme_classic())

p4 <- (ggplot(md, aes(x=percent.ribo, fill=pass_QC)) +
  geom_density(alpha=0.4, position = 'identity') +
  labs(fill="") +
  theme_classic())

grid.arrange(p1, p2, p3, p4, ncol=4)
```

## Doublet Detection

Next, let's search for doublets. As far as I know, Seurat has no good inbuilt method for doing this. A good comparison of methods is [this](https://doi.org/10.1093/bioinformatics/btz698) paper. When benchmarking methods myself, I found their hybrid method worked best + 1 round of guilt-by-association, where I remove any cells that are very similar to cells called as doublets. Their method takes the data in a different format, so we need to conver the data from Seurat to SingleCellExperiment
```{r, DoubletDetection}
pbmc3k <- subset(pbmc3k, subset = nFeature_RNA>min_nFeature_RNA & nCount_RNA>min_nCount_RNA & percent.mt>min_percent.mt & percent.mt<max_percent.mt)

pbmc3k_sce <- as.SingleCellExperiment(pbmc3k)
pbmc3k_sce <- cxds_bcds_hybrid(pbmc3k_sce, estNdbl=TRUE)
pbmc3k <- AddMetaData(
  object = pbmc3k,
  metadata = pbmc3k_sce$hybrid_call,
  col.name = "doublet"
)

pbmc3k <- subset(pbmc3k, subset = doublet==FALSE)
```


### a side note
On my own data, I don't find this to be enough. When I was able to have more of a ground truth doublet calling (using cell hashing and genotyping) I found that this only got me to a TPR of 41% (on differentating cell line data), and 50% (on differentiating mESC data). Therefore, I remove any cells that are similar to called doublets, and thereby was able to get my TPR to 82% and 79%, respectively. This step completely overkills on this toy dataset, but I'll include my code here, in case you want to try it in the future:

```{r, further_doublet_calling, eval=FALSE}
pbmc3k <- NormalizeData(pbmc3k)
pbmc3k <- FindVariableFeatures(pbmc3k)
pbmc3k <- ScaleData(pbmc3k)
pbmc3k <- RunPCA(pbmc3k, verbose=FALSE)
pbmc3k <- FindNeighbors(pbmc3k, k.param=10, reduction = "pca")

md <- pbmc3k@meta.data

tmp <- data.table(hybrid_map = rowSums(pbmc3k@graphs$RNA_nn[,md[hybrid_call==TRUE]$cell])/10,
                  barcode = rownames(pbmc3k@graphs$RNA_snn))
md <- merge(md, tmp, by = "barcode", all.x=TRUE)
md[hybrid_call==TRUE, hybrid_map := NA]
md[,hybrid_call2 := TRUE]
md[hybrid_map<=((sum(md$hybrid_call==TRUE))/(dim(md)[1])), hybrid_call2 := FALSE]
rownames(md) <- md$cell
```

# Variance Stabilising Transformation

```{r, Mean_Variance_Relationship, fig.height=4, fig.width=4}
means <- rowMeans(as.matrix(pbmc3k@assays$RNA@counts))
variance <- rowVars(as.matrix(pbmc3k@assays$RNA@counts))
p1 <- plot(means, variance)
print(p1)
```

```{r, Normalisation, fig.height=4, fig.width=4}
pbmc3k <- NormalizeData(pbmc3k, normalization.method = "LogNormalize")

means <- rowMeans(pbmc3k@assays$RNA@data)
variance <- rowVars(pbmc3k@assays$RNA@data)
p <- plot(means, variance)
print(p)
```

Does the log normalisation solve the problem? Are we still biasing towards a certain type of gene?

# Highly Variable Gene Selection

```{r, HVG_Selec, fig.height=4, fig.width=4}
pbmc3k <- FindVariableFeatures(pbmc3k)

to.plot <- data.table(means=rowMeans(pbmc3k@assays$RNA@data),
                      variance=rowVars(pbmc3k@assays$RNA@data),
                      hvg=(rownames(pbmc3k@assays$RNA@data) %in% VariableFeatures(pbmc3k)))

p <- ggplot(data=to.plot, mapping = aes(x=means, y=variance, colour=hvg)) +
  geom_point(size=0.5, alpha=1) +
  guides(colour = guide_legend(override.aes = list(size=1))) +
  theme_classic()
print(p)
```

# Scaling the Data

```{r, ScaleData, fig.height=4, fig.width=4}
pbmc3k <- ScaleData(pbmc3k)

means <- rowMeans(pbmc3k@assays$RNA@scale.data)
variance <- rowVars(pbmc3k@assays$RNA@scale.data)
p1 <- plot(means, variance)
print(p1)

p2 <- hist(means)
print(p2)

p2 <- hist(variance)
print(p2)
```

# Clustering

```{r, Clustering, fig.height=4, fig.width=4}
pbmc3k <- RunPCA(pbmc3k, verbose=FALSE)
pbmc3k <- FindNeighbors(pbmc3k, k.param=10, reduction = "pca")
pbmc3k <- FindClusters(pbmc3k, resolution = 0.5)
p <- ggplot(data=as.data.table(pbmc3k@meta.data)[,.N,by="seurat_clusters"], mapping = aes(x=seurat_clusters, y=N)) +
  geom_bar(stat="identity") +
  labs(x="Cluster Number", y="Number of Cells in that Cluster") +
  theme_classic()
print(p)
```

# Cluster Marker Genes

```{r, MarkerGenes}
cluster1.markers <- FindMarkers(pbmc3k, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
```

Luckily, in this dataset we know the cell types very well and have known marker genes. From [the vignette](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html):

| Markers	| Cell Type |
|---|---|
| IL7R, CCR7	| Naive CD4+ T |
| IL7R, S100A4	| Memory CD4+ |
| CD14, LYZ	| CD14+ Mono |
| MS4A1	| B |
| CD8A	| CD8+ T |
| FCGR3A, MS4A7	FCGR3A+ | Mono |
| GNLY, NKG7	| NK |
| FCER1A, CST3	| DC |
| PPBP	| Platelet |

Based on this, Seurat has already annotated the cells. Let's visualise.
Do they agree with our clusters? Why not?

# Visualisation

```{r, Visualisation1, fig.height=4, fig.width=4}
pbmc3k <- RunUMAP(pbmc3k, dims = 1:10)
DimPlot(pbmc3k, reduction = "umap")
DimPlot(pbmc3k, reduction = "umap", group.by = "seurat_annotations")
```

```{r, Visualisation2, fig.height=20, fig.width=20}
FeaturePlot(pbmc3k, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
    "CD8A"))
```

# SHINY

Finally, let's export our metadata for your next practical!

```{r, ExportMetaData}
feats <- as.data.table(t(pbmc3k@assays$RNA@data[c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A"),]))
for_shiny <- cbind(as.data.table(pbmc3k@meta.data), feats)
umap_coords <- as.data.table(pbmc3k@reductions$umap@cell.embeddings)
for_shiny <- cbind(for_shiny, umap_coords)
saveRDS(for_shiny, "sc_output.rds")
```

